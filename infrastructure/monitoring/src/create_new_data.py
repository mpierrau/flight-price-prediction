"""
Here are some functions that help us generate synthetic data,
both valid and invalid. This helps us test our monitoring
methods, to see if they catch different types of drift.

The invalid choices are set to sometimes be invalid and sometimes
valid. This is to (randomly) get a distribution of correct and incorrect
values.
"""

import random
from typing import Any, Callable

import click
import pandas as pd


def get_val_from_choice(
    valid_choices: list[Any] | range,
    invalid_choices: list[Any] | range,
    allow_invalid: bool = False,
) -> Any:
    """
    Helper function for selecting one item from either of two lists.

    Args:
        valid_choices (list[Any]): Values that are observed in the training data.
        invalid_choices (list[Any]): Values that are not observed in the training data.
        allow_invalid (bool, optional): Whether to include invalid values in return.
            Defaults to False.

    Returns:
        Any: One of the entries from the given lists
    """
    r = valid_choices if not allow_invalid else invalid_choices
    return random.choice(r)


def get_total_stop(allow_invalid: bool = False) -> int:
    """Get number of stops"""
    return get_val_from_choice(range(5), range(-10, 10), allow_invalid)


def get_day(allow_invalid: bool = False) -> int:
    """Get day of month number. Limiting at 28 to simplify
    the valid dates given the various months."""
    return get_val_from_choice(range(1, 28), range(50), allow_invalid)


def get_month(allow_invalid: bool = False) -> int:
    """Get number of month"""
    return get_val_from_choice(range(1, 13), range(30), allow_invalid)


def get_year(allow_invalid: bool = False) -> int:
    """Get year. Future years are fine."""
    return get_val_from_choice(range(1990, 2050), range(-100, 100), allow_invalid)


def get_hour(allow_invalid: bool = False) -> int:
    """Get hour of day"""
    return get_val_from_choice(range(24), range(30), allow_invalid)


def get_minute(allow_invalid: bool = False) -> int:
    """Get minute of the hour"""
    return get_val_from_choice(range(60), range(80), allow_invalid)


def get_airline(allow_invalid: bool = False) -> str:
    """Get name of airline."""
    valid_airlines = [
        "Air Asia",
        "Air India",
        "Indigo",
        "Jet Airways",
        "Multiple carriers",
        "Multiple carriers Premium economy",
        "Spice Jet",
        "Truejet",
        "Vistara",
        "Vistara Premium economy",
    ]
    invalid_airlines = [
        "SAS",
        "Lufthansa",
        "easyJet",
        "RyanAir",
        "Delta Airlines",
        "Turkish Airlines",
        "Air Canada",
        "United Airlines",
        "Soutwest Airlines",
        "American Airlines",
    ]
    return get_val_from_choice(valid_airlines, invalid_airlines, allow_invalid)


def get_source(allow_invalid: bool = False) -> str:
    """Get name of flight source."""
    valid_sources = [
        "Banglore",
        "Kolkata",
        "Chennai",
        "Delhi",
        "Mumbai",
    ]
    invalid_sources = [
        "Harare",
        "Copenhagen",
        "Helsinki",
        "Vancouver",
        "New York",
        "Amsterdam",
        "Lima",
        "London",
    ]
    return get_val_from_choice(valid_sources, invalid_sources, allow_invalid)


def get_destination(allow_invalid: bool = False) -> str:
    """Get name of flight destination."""
    valid_destinations = [
        "Banglore",
        "Kolkata",
        "Cochin",
        "Delhi",
        "Hyderabad",
        "New Delhi",
    ]
    invalid_destinations = [
        "Los Angeles",
        "Sydney",
        "Paris",
        "Barcelona",
        "Cairo",
        "Kyiv",
    ]
    return get_val_from_choice(valid_destinations, invalid_destinations, allow_invalid)


def get_price(allow_invalid: bool = False) -> int:
    """Get flight price, sampled uniformly between hardcoded
    min and max values"""
    valid_values_minmax = (1759, 79512)
    invalid_values_minmax = (60000, 300000)
    r = (
        random.randint(*valid_values_minmax)
        if not allow_invalid
        else random.randint(*invalid_values_minmax)
    )
    return r


def get_func_n(func: Callable, n: int, *args, **kwargs) -> list[Any]:
    """
    Helper function for returning a list with n entries
    generated by the function func with arguments args and
    kwargs.

    Args:
        func (Callable): Function to call
        n (int): Number of function call values to return

    Returns:
        list[Any]: List with function results
    """
    return [func(*args, **kwargs) for _ in range(n)]


def create_random_new_data(
    n_samples: int, allow_invalid_data: bool, random_seed: int
) -> pd.DataFrame:
    """
    Create new synthetic data that we can
    give to the monitoring service.
    Has the same columns as training data before
    feature engineering.
    """
    random.seed(random_seed)

    # Just wrapping it in a local function for brevity
    def f_n_times(func) -> list[Any]:
        return get_func_n(func, n_samples, allow_invalid_data)

    data = {
        "total_stops": f_n_times(get_total_stop),
        "date": f_n_times(get_day),
        "month": f_n_times(get_month),
        "year": f_n_times(get_year),
        "dep_hours": f_n_times(get_hour),
        "dep_min": f_n_times(get_minute),
        "arrival_hours": f_n_times(get_hour),
        "arrival_min": f_n_times(get_minute),
        "duration_hours": f_n_times(get_hour),
        "duration_min": f_n_times(get_minute),
        "airline": f_n_times(get_airline),
        "source": f_n_times(get_source),
        "destination": f_n_times(get_destination),
        "price": f_n_times(get_price),
    }
    df = pd.DataFrame(data)
    return df


@click.command()
@click.option("-n", "--n-samples", type=int, default=2)
@click.option("-invalid", "--allow-invalid-data", is_flag=True)
@click.option("-s", "--random_seed", type=int, default=None)
def create_random_new_data_wrapper(*args, **kwargs):
    """Arg wrapper function"""
    create_random_new_data(*args, **kwargs)


if __name__ == '__main__':
    create_random_new_data_wrapper()
